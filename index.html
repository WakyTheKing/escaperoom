<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Queen Maze NFC Game</title>
<style>
  /* Reset & base */
  * {
    box-sizing: border-box;
    -webkit-tap-highlight-color: transparent;
  }
  body, html {
    margin: 0; padding: 0; height: 100%; background: #111;
    display: flex; justify-content: center; align-items: center;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
      Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
    user-select: none;
    -webkit-user-select: none;
  }
  #game {
    width: 95vw; max-width: 430px; /* iPhone 16 Pro Max ~430pt wide */
    aspect-ratio: 1 / 1;
    background: #222;
    border-radius: 15px;
    box-shadow: 0 0 20px #333;
    position: relative;
    overflow: hidden;
  }
  /* Chessboard container */
  #board {
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    grid-template-rows: repeat(8, 1fr);
    width: 100%;
    height: 100%;
    transition: transform 1s ease;
    transform-origin: center bottom;
  }
  /* Squares */
  .square {
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 2.4rem;
    cursor: default;
    user-select: none;
    transition: background-color 0.3s ease, filter 0.3s ease;
  }
  /* Standard chessboard colors */
  .square.light {
    background-color: #f0d9b5;
  }
  .square.dark {
    background-color: #b58863;
  }
  /* Grayed out pieces */
  .piece.grayed {
    filter: grayscale(100%) brightness(0.5);
    pointer-events: none;
  }
  /* Queen piece */
  .queen {
    color: #fff;
    font-weight: bold;
    cursor: pointer;
    filter: drop-shadow(0 0 2px #0ff);
  }
  /* Door square */
  .door {
    position: relative;
    font-size: 2rem;
    color: #f4a261;
    cursor: pointer;
    filter: drop-shadow(0 0 3px #f4a261);
  }
  /* Maze walls */
  .wall {
    background-color: #444;
  }
  /* Highlight possible moves */
  .highlight {
    box-shadow: inset 0 0 0 4px #0ff;
  }
  /* Highlight selected square */
  .selected {
    box-shadow: inset 0 0 8px 4px #06f;
  }
  /* Animation for queen movement */
  .queen.moving {
    transition: transform 0.3s ease;
  }
  /* Overlay for QR scanner popup */
  #scannerOverlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.85);
    display: none;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    z-index: 9999;
    color: white;
    font-size: 1.1rem;
    padding: 20px;
  }
  #scannerOverlay video {
    width: 90vw;
    max-width: 400px;
    border-radius: 12px;
    box-shadow: 0 0 20px #0ff;
  }
  #scannerOverlay button {
    margin-top: 20px;
    background: #0ff;
    border: none;
    border-radius: 10px;
    color: #000;
    font-weight: 600;
    font-size: 1.2rem;
    padding: 10px 20px;
    cursor: pointer;
  }
  /* Popup for messages */
  #popup {
    position: fixed;
    top: 10%;
    left: 50%;
    transform: translateX(-50%);
    background: #222;
    border-radius: 15px;
    padding: 20px 30px;
    color: #0ff;
    font-size: 1.4rem;
    box-shadow: 0 0 20px #0ff;
    z-index: 10000;
    display: none;
    max-width: 90vw;
    text-align: center;
  }
  #popup.error {
    color: #f44;
    box-shadow: 0 0 20px #f44;
  }
  #popup.success {
    color: #4f4;
    box-shadow: 0 0 20px #4f4;
  }
</style>
</head>
<body>

<div id="game" aria-label="Queen maze chessboard game">
  <div id="board" aria-live="polite" aria-atomic="true" role="grid" aria-label="Chessboard">
    <!-- Squares generated by JS -->
  </div>
</div>

<!-- Scanner Overlay -->
<div id="scannerOverlay" role="dialog" aria-modal="true" aria-labelledby="scannerTitle">
  <div id="scannerTitle" style="margin-bottom: 10px;">Scan QR Code (Virtual NFC Key)</div>
  <video id="video" autoplay playsinline></video>
  <canvas id="canvas" style="display: none;"></canvas>
  <button id="closeScannerBtn" aria-label="Close scanner">Cancel</button>
</div>

<!-- Popup messages -->
<div id="popup" role="alert" aria-live="assertive"></div>

<script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
<script>
/**
 * Queen Maze NFC Game
 * 
 * Features:
 * - Initial screen: 8x8 chessboard with all pieces grayed out except the white queen at bottom.
 * - Tap queen to expand board and reveal maze layout.
 * - Tap adjacent squares to move queen through maze.
 * - Final door tile unlocks when user scans correct QR code (virtual NFC key).
 * - Shows secret code on success.
 * 
 * Optimized for iPhone 16 Pro Max screen and touch input.
 * 
 * Author: ChatGPT
 */

// === Configuration ===

// Changed NFC key code to "Jocelyn"
const NFC_KEY_CODE = "Jocelyn";

// Secret code revealed when door unlocks
const SECRET_CODE = "42-A1B2-C3D4";

// Board size (8x8 standard chessboard)
const BOARD_SIZE = 8;

// Unicode chess pieces for simplicity
const PIECES = {
  whiteQueen: "â™•",
  door: "ðŸšª"
};

// Maze layout:
// 0 = empty/passable
// 1 = wall
// 2 = door
const MAZE = [
  [1,1,1,1,1,1,1,1],
  [1,0,0,0,1,0,0,1],
  [1,0,1,0,1,0,1,1],
  [1,0,1,0,0,0,0,1],
  [1,0,1,1,1,1,0,1],
  [1,0,0,0,0,1,0,1],
  [1,1,1,1,0,0,0,1],
  [1,1,1,1,1,1,2,1] // Door position
];

// Coordinates for door (row, col) in maze
const DOOR_POS = {r: 7, c: 6};

// Initial queen position (bottom row, d1 square)
const INITIAL_QUEEN_POS = {r:7, c:3};

// === Global variables ===
let boardEl = null;
let squares = [];
let queenPos = {...INITIAL_QUEEN_POS};
let expanded = false;
let moving = false;
let doorUnlocked = false;

let scannerOverlay = null;
let video = null;
let canvas = null;
let stream = null;
let popupEl = null;
let scanInterval = null;

// === Initialization ===
window.onload = () => {
  boardEl = document.getElementById("board");
  scannerOverlay = document.getElementById("scannerOverlay");
  video = document.getElementById("video");
  canvas = document.getElementById("canvas");
  popupEl = document.getElementById("popup");

  generateBoard();
  updateBoardInitial();

  squares[getIndex(INITIAL_QUEEN_POS.r, INITIAL_QUEEN_POS.c)].addEventListener("click", onQueenTap);
  document.getElementById("closeScannerBtn").addEventListener("click", stopScanner);
}

function generateBoard(){
  for(let r=0; r<BOARD_SIZE; r++){
    for(let c=0; c<BOARD_SIZE; c++){
      let sq = document.createElement("div");
      sq.classList.add("square");
      if((r+c)%2===0) {
        sq.classList.add("light");
      } else {
        sq.classList.add("dark");
      }
      
      sq.setAttribute("data-row", r);
      sq.setAttribute("data-col", c);
      sq.setAttribute("role", "gridcell");
      sq.setAttribute("aria-label", `Square ${String.fromCharCode(97+c)}${8-r}`);
      
      boardEl.appendChild(sq);
      squares.push(sq);
    }
  }
}

function getIndex(r, c){
  return r * BOARD_SIZE + c;
}

function updateBoardInitial(){
  // Standard chess pieces
  const initialPieces = [
    // Black pieces (top)
    "â™œ","â™ž","â™","â™›","â™š","â™","â™ž","â™œ",
    "â™Ÿ","â™Ÿ","â™Ÿ","â™Ÿ","â™Ÿ","â™Ÿ","â™Ÿ","â™Ÿ",
    "", "", "", "", "", "", "", "",
    "", "", "", "", "", "", "", "",
    "", "", "", "", "", "", "", "",
    "", "", "", "", "", "", "", "",
    // White pieces (bottom)
    "â™™","â™™","â™™","â™™","â™™","â™™","â™™","â™™",
    "â™–","â™˜","â™—","â™•","â™”","â™—","â™˜","â™–"
  ];

  squares.forEach((sq, idx) => {
    sq.innerHTML = "";
    let piece = initialPieces[idx];
    if(piece) {
      let pieceEl = document.createElement("span");
      pieceEl.className = "piece grayed";
      pieceEl.textContent = piece;
      sq.appendChild(pieceEl);
    }
  });

  // Make white queen active
  let queenSq = squares[getIndex(INITIAL_QUEEN_POS.r, INITIAL_QUEEN_POS.c)];
  let queenPiece = queenSq.querySelector(".piece");
  if(queenPiece) {
    queenPiece.classList.remove("grayed");
    queenPiece.classList.add("queen");
  }
}

function onQueenTap(){
  if(expanded || moving) return;
  
  showPopup("Revealing maze...", "");
  
  setTimeout(() => {
    expandToMaze();
    hidePopup();
  }, 1000);
}

function expandToMaze(){
  expanded = true;
  
  // Clear all squares and apply maze layout
  squares.forEach((sq, idx) => {
    sq.innerHTML = "";
    sq.className = "square";
    
    let r = Math.floor(idx / BOARD_SIZE);
    let c = idx % BOARD_SIZE;
    
    // Add light/dark coloring
    if((r+c)%2===0) {
      sq.classList.add("light");
    } else {
      sq.classList.add("dark");
    }
    
    let mazeValue = MAZE[r][c];
    if(mazeValue === 1) {
      sq.classList.add("wall");
    } else if(mazeValue === 2) {
      // Door
      let doorEl = document.createElement("span");
      doorEl.className = "door";
      doorEl.textContent = PIECES.door;
      sq.appendChild(doorEl);
      sq.addEventListener("click", onDoorTap);
    }
    
    // Add click handler for movement
    if(mazeValue === 0 || mazeValue === 2) {
      sq.addEventListener("click", (e) => onSquareTap(r, c));
    }
  });
  
  // Place queen at initial position
  placeQueen(queenPos.r, queenPos.c);
  
  // Visual expansion effect
  boardEl.style.transform = "scale(1.05)";
  setTimeout(() => {
    boardEl.style.transform = "scale(1)";
  }, 500);
}

function placeQueen(r, c){
  // Remove queen from all squares
  squares.forEach(sq => {
    let queen = sq.querySelector(".queen");
    if(queen) queen.remove();
  });
  
  // Place queen at new position
  let targetSq = squares[getIndex(r, c)];
  let queenEl = document.createElement("span");
  queenEl.className = "piece queen";
  queenEl.textContent = PIECES.whiteQueen;
  targetSq.appendChild(queenEl);
  
  queenPos = {r, c};
}

function onSquareTap(r, c){
  if(moving || !expanded) return;
  
  // Check if it's an adjacent square
  let dr = Math.abs(r - queenPos.r);
  let dc = Math.abs(c - queenPos.c);
  
  if(dr <= 1 && dc <= 1 && (dr !== 0 || dc !== 0)) {
    // Valid adjacent move
    if(MAZE[r][c] === 0 || MAZE[r][c] === 2) {
      moveQueen(r, c);
    }
  } else {
    // Highlight valid moves briefly
    highlightValidMoves();
  }
}

function moveQueen(r, c){
  moving = true;
  placeQueen(r, c);
  
  setTimeout(() => {
    moving = false;
  }, 300);
}

function highlightValidMoves(){
  // Clear existing highlights
  squares.forEach(sq => sq.classList.remove("highlight"));
  
  // Highlight adjacent valid squares
  for(let dr = -1; dr <= 1; dr++){
    for(let dc = -1; dc <= 1; dc++){
      if(dr === 0 && dc === 0) continue;
      
      let nr = queenPos.r + dr;
      let nc = queenPos.c + dc;
      
      if(nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE){
        if(MAZE[nr][nc] === 0 || MAZE[nr][nc] === 2){
          squares[getIndex(nr, nc)].classList.add("highlight");
        }
      }
    }
  }
  
  // Remove highlights after 2 seconds
  setTimeout(() => {
    squares.forEach(sq => sq.classList.remove("highlight"));
  }, 2000);
}

function onDoorTap(){
  if(!expanded || moving || doorUnlocked) return;
  
  // Check if queen is adjacent to door
  let dr = Math.abs(DOOR_POS.r - queenPos.r);
  let dc = Math.abs(DOOR_POS.c - queenPos.c);
  
  if(dr <= 1 && dc <= 1) {
    // Queen is adjacent, open scanner
    startScanner();
  } else {
    showPopup("Move closer to the door!", "error");
    setTimeout(hidePopup, 2000);
    highlightValidMoves();
  }
}

function startScanner(){
  scannerOverlay.style.display = "flex";
  
  navigator.mediaDevices.getUserMedia({ 
    video: { 
      facingMode: "environment",
      width: { ideal: 320 },
      height: { ideal: 320 }
    } 
  })
  .then(mediaStream => {
    stream = mediaStream;
    video.srcObject = stream;
    video.play();
    
    // Start scanning for QR codes
    scanInterval = setInterval(scanForQR, 100);
  })
  .catch(err => {
    console.error("Camera error:", err);
    showPopup("Camera access denied or not available", "error");
    setTimeout(() => {
      hidePopup();
      stopScanner();
    }, 3000);
    
    // Fallback for testing
    setTimeout(() => {
      if(confirm("Camera failed. Use test key 'Jocelyn' for demo?")) {
        checkNFCKey("Jocelyn");
      }
    }, 1000);
  });
}

function scanForQR(){
  if(!video.videoWidth || !video.videoHeight) return;
  
  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;
  
  const ctx = canvas.getContext('2d');
  ctx.drawImage(video, 0, 0);
  
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  
  try {
    const qrCode = jsQR(imageData.data, imageData.width, imageData.height);
    
    if(qrCode && qrCode.data) {
      console.log("QR Code detected:", qrCode.data);
      clearInterval(scanInterval);
      stopScanner();
      checkNFCKey(qrCode.data);
    }
  } catch(e) {
    // jsQR failed, continue scanning
  }
}

function stopScanner(){
  scannerOverlay.style.display = "none";
  
  if(scanInterval) {
    clearInterval(scanInterval);
    scanInterval = null;
  }
  
  if(stream) {
    stream.getTracks().forEach(track => track.stop());
    stream = null;
  }
  
  video.srcObject = null;
}

function checkNFCKey(scannedData){
  if(scannedData.includes(NFC_KEY_CODE)) {
    // Correct key
    doorUnlocked = true;
    
    // Update door appearance
    let doorSq = squares[getIndex(DOOR_POS.r, DOOR_POS.c)];
    doorSq.style.backgroundColor = "#4f4";
    
    showPopup(`Success! Secret Code: ${SECRET_CODE}`, "success");
    
    console.log("Door unlocked! Secret code:", SECRET_CODE);
  } else {
    // Wrong key
    showPopup("Incorrect QR code. Try again!", "error");
    setTimeout(hidePopup, 3000);
  }
}

function showPopup(message, type = ""){
  popupEl.textContent = message;
  popupEl.className = type;
  popupEl.style.display = "block";
}

function hidePopup(){
  popupEl.style.display = "none";
}

console.log("Queen Maze Game loaded. QR Key:", NFC_KEY_CODE);
</script>
</body>
</html>